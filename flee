-- Load Obsidian Library
local repo = "https://raw.githubusercontent.com/deividcomsono/Obsidian/main/"
local Library = loadstring(game:HttpGet(repo .. "Library.lua"))()
local SaveManager = loadstring(game:HttpGet(repo .. "addons/SaveManager.lua"))()

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

local LocalPlayer = Players.LocalPlayer

-- State Management
local State = {
    AutoSolveMinigame = false,
    SelectedPlayerForChance = nil,
    SelectedComputer = nil,
    ESPBeast = false,
    ESPPlayers = false,
    ESPComputers = false,
    ESPFreezePods = false,
    ESPExitDoors = false,
    WalkSpeed = 16,
    JumpPower = 50,
    NoClip = false,
    AntiBeast = false,
}

-- Cache for objects
local Cache = {
    Computers = {},
    FreezePods = {},
    ExitDoors = {},
    ObjectsDirty = true,
}

-- ESP Storage
local ESPObjects = {
    Players = {},
    Beasts = {},
    Computers = {},
    FreezePods = {},
    ExitDoors = {},
}

-- Connections
local MinigameConnection = nil
local NoClipConnection = nil
local AntiBeastConnection = nil

-- Create Window
local Window = Library:CreateWindow({
    Title = "XXMZ",
    Footer = "Flee The Facility",
    Icon = 95816097006870,
    NotifySide = "Right",
})

-- Create Tabs
local Tabs = {
    Main = Window:AddTab({
        Name = "Main",
        Description = "Funcionalidades principais",
        Icon = "home"
    }),
    ESP = Window:AddTab({
        Name = "ESP",
        Description = "Visualizações",
        Icon = "eye"
    }),
    Player = Window:AddTab({
        Name = "Player",
        Description = "Modificações do jogador",
        Icon = "user"
    }),
    Settings = Window:AddTab({
        Name = "UI Settings",
        Description = "Configurações da interface",
        Icon = "settings"
    }),
}

-- ========================================
-- HELPER FUNCTIONS
-- ========================================

local function isBeast(player)
    return player.Character ~= nil and player.Character:FindFirstChild("Hammer") ~= nil
end

local function rebuildObjectCache()
    Cache.Computers = {}
    Cache.FreezePods = {}
    Cache.ExitDoors = {}
    for _, d in ipairs(Workspace:GetDescendants()) do
        if d:IsA("Model") then
            local n = d.Name
            if n == "ComputerTable" then 
                table.insert(Cache.Computers, d)
            elseif n == "FreezePod" then 
                table.insert(Cache.FreezePods, d)
            elseif n == "ExitDoor" then 
                table.insert(Cache.ExitDoors, d)
            end
        end
    end
    Cache.ObjectsDirty = false
end

-- ========================================
-- AUTO SOLVE MINIGAME
-- ========================================

local LastSolveTime = 0
local function startAutoSolve()
    if MinigameConnection then return end
    MinigameConnection = RunService.Heartbeat:Connect(function()
        if not State.AutoSolveMinigame then return end
        
        local currentTime = tick()
        if currentTime - LastSolveTime >= 0.2 then
            local rem = ReplicatedStorage:FindFirstChild("RemoteEvent")
            if rem then 
                rem:FireServer("SetPlayerMinigameResult", true)
                LastSolveTime = currentTime
            end
        end
    end)
end

local function stopAutoSolve()
    if MinigameConnection then 
        MinigameConnection:Disconnect()
        MinigameConnection = nil
    end
end

-- ========================================
-- ESP FUNCTIONS
-- ========================================

local function createESP(object, color, text, icon)
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "ESP"
    billboard.Adornee = object
    billboard.Size = UDim2.new(0, 100, 0, 50)
    billboard.StudsOffset = Vector3.new(0, 2, 0)
    billboard.AlwaysOnTop = true
    
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(1, 0, 1, 0)
    frame.BackgroundTransparency = 0.5
    frame.BackgroundColor3 = color
    frame.BorderSizePixel = 0
    frame.Parent = billboard
    
    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.Text = text
    label.TextColor3 = Color3.new(1, 1, 1)
    label.TextScaled = true
    label.Font = Enum.Font.GothamBold
    label.Parent = frame
    
    billboard.Parent = object
    return billboard
end

local function updatePlayerESP()
    -- Clear old ESP
    for _, esp in pairs(ESPObjects.Players) do
        if esp then esp:Destroy() end
    end
    for _, esp in pairs(ESPObjects.Beasts) do
        if esp then esp:Destroy() end
    end
    ESPObjects.Players = {}
    ESPObjects.Beasts = {}
    
    -- Create new ESP
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            if isBeast(player) and State.ESPBeast then
                local esp = createESP(player.Character.HumanoidRootPart, Color3.fromRGB(255, 0, 0), "BEAST: " .. player.Name, "skull")
                ESPObjects.Beasts[player.Name] = esp
            elseif not isBeast(player) and State.ESPPlayers then
                local esp = createESP(player.Character.HumanoidRootPart, Color3.fromRGB(0, 255, 0), player.Name, "user")
                ESPObjects.Players[player.Name] = esp
            end
        end
    end
end

local function updateObjectESP()
    -- Clear old ESP
    for _, esp in pairs(ESPObjects.Computers) do
        if esp then esp:Destroy() end
    end
    for _, esp in pairs(ESPObjects.FreezePods) do
        if esp then esp:Destroy() end
    end
    for _, esp in pairs(ESPObjects.ExitDoors) do
        if esp then esp:Destroy() end
    end
    ESPObjects.Computers = {}
    ESPObjects.FreezePods = {}
    ESPObjects.ExitDoors = {}
    
    if Cache.ObjectsDirty then
        rebuildObjectCache()
    end
    
    -- Computers
    if State.ESPComputers then
        for i, computer in ipairs(Cache.Computers) do
            local primary = computer:FindFirstChild("ComputerTable") or computer.PrimaryPart
            if primary then
                local esp = createESP(primary, Color3.fromRGB(0, 150, 255), "Computer", "monitor")
                ESPObjects.Computers[i] = esp
            end
        end
    end
    
    -- FreezePods
    if State.ESPFreezePods then
        for i, pod in ipairs(Cache.FreezePods) do
            local primary = pod.PrimaryPart or pod:FindFirstChildWhichIsA("BasePart")
            if primary then
                local esp = createESP(primary, Color3.fromRGB(100, 100, 255), "Freeze Pod", "droplet")
                ESPObjects.FreezePods[i] = esp
            end
        end
    end
    
    -- Exit Doors
    if State.ESPExitDoors then
        for i, door in ipairs(Cache.ExitDoors) do
            local primary = door.PrimaryPart or door:FindFirstChildWhichIsA("BasePart")
            if primary then
                local esp = createESP(primary, Color3.fromRGB(255, 255, 0), "Exit Door", "door-open")
                ESPObjects.ExitDoors[i] = esp
            end
        end
    end
end

-- ========================================
-- PLAYER MODIFICATIONS
-- ========================================

local function updateWalkSpeed()
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        LocalPlayer.Character.Humanoid.WalkSpeed = State.WalkSpeed
    end
end

local function updateJumpPower()
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        LocalPlayer.Character.Humanoid.JumpPower = State.JumpPower
    end
end

-- Estado original das colisões
local OriginalCanCollide = {}

local function startNoClip()
    if NoClipConnection then return end
    
    -- Salvar estado original das partes
    if LocalPlayer.Character then
        for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
            if part:IsA("BasePart") then
                OriginalCanCollide[part] = part.CanCollide
            end
        end
    end
    
    NoClipConnection = RunService.Stepped:Connect(function()
        if not State.NoClip then return end
        if LocalPlayer.Character then
            for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end
    end)
end

local function stopNoClip()
    if NoClipConnection then
        NoClipConnection:Disconnect()
        NoClipConnection = nil
    end
    
    -- Restaurar estado original das partes
    if LocalPlayer.Character then
        for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
            if part:IsA("BasePart") and OriginalCanCollide[part] ~= nil then
                part.CanCollide = OriginalCanCollide[part]
            end
        end
    end
    
    -- Limpar cache
    OriginalCanCollide = {}
end

local function startAntiBeast()
    if AntiBeastConnection then return end
    AntiBeastConnection = RunService.Heartbeat:Connect(function()
        if not State.AntiBeast then return end
        if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return end
        
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and isBeast(player) and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local distance = (LocalPlayer.Character.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).Magnitude
                if distance < 30 then
                    LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(126, 4, -373)
                    Library:Notify("Anti-Beast ativado! Teleportado para segurança.", 3)
                    break
                end
            end
        end
    end)
end

local function stopAntiBeast()
    if AntiBeastConnection then
        AntiBeastConnection:Disconnect()
        AntiBeastConnection = nil
    end
end

-- ========================================
-- MAIN TAB
-- ========================================

local MainLeft = Tabs.Main:AddLeftGroupbox("Auto Farm", "zap")
local MainRight = Tabs.Main:AddRightGroupbox("Beast Chance", "percent")

-- Auto Solve Minigame
MainLeft:AddToggle("AutoSolve", {
    Text = "Auto Solve Minigame",
    Default = false,
    Callback = function(value)
        State.AutoSolveMinigame = value
        if value then
            startAutoSolve()
            Library:Notify("Auto Solve ativado!", 2)
        else
            stopAutoSolve()
            Library:Notify("Auto Solve desativado!", 2)
        end
    end
})

MainLeft:AddLabel("Resolve minigames automaticamente (1x/s)", false)

-- Beast Chance Checker
local BeastChanceDropdown = MainRight:AddDropdown("PlayerChance", {
    Text = "Selecionar Jogador",
    Values = {},
    Default = 1,
    Multi = false,
    Callback = function(value)
        State.SelectedPlayerForChance = value
    end
})

local BeastChanceResult = MainRight:AddLabel("Selecione um jogador", false)

-- Teleport Section
local TeleportBox = Tabs.Main:AddLeftGroupbox("Teleporte", "navigation")

local ComputerDropdown = TeleportBox:AddDropdown("ComputerSelect", {
    Text = "Selecionar Computador",
    Values = {},
    Default = 1,
    Multi = false,
    Callback = function(value)
        State.SelectedComputer = value
    end
})

TeleportBox:AddButton("Teleportar para Computador", function()
    if not State.SelectedComputer then
        Library:Notify("Selecione um computador primeiro!", 3)
        return
    end
    
    if Cache.ObjectsDirty then rebuildObjectCache() end
    
    local computerIndex = tonumber(State.SelectedComputer:match("%d+"))
    if computerIndex and Cache.Computers[computerIndex] then
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local computer = Cache.Computers[computerIndex]
            local primary = computer:FindFirstChild("ComputerTable") or computer.PrimaryPart
            if primary then
                -- Teleporta na frente do computador
                local offset = primary.CFrame.LookVector * 5
                LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(primary.Position + offset) * CFrame.Angles(0, math.atan2(offset.X, offset.Z), 0)
                Library:Notify("Teleportado para " .. State.SelectedComputer .. "!", 2)
            else
                Library:Notify("Erro ao encontrar parte do computador!", 3)
            end
        else
            Library:Notify("Character não encontrado!", 3)
        end
    else
        Library:Notify("Computador não encontrado!", 3)
    end
end)

-- ========================================
-- ESP TAB
-- ========================================

local ESPPlayers = Tabs.ESP:AddLeftGroupbox("ESP Jogadores", "users")
local ESPObjects = Tabs.ESP:AddRightGroupbox("ESP Objetos", "box")

ESPPlayers:AddToggle("ESPBeast", {
    Text = "ESP Beast",
    Default = false,
    Callback = function(value)
        State.ESPBeast = value
        updatePlayerESP()
    end
})

ESPPlayers:AddToggle("ESPPlayers", {
    Text = "ESP Players",
    Default = false,
    Callback = function(value)
        State.ESPPlayers = value
        updatePlayerESP()
    end
})

ESPObjects:AddToggle("ESPComputers", {
    Text = "ESP Computers",
    Default = false,
    Callback = function(value)
        State.ESPComputers = value
        updateObjectESP()
    end
})

ESPObjects:AddToggle("ESPFreezePods", {
    Text = "ESP Freeze Pods",
    Default = false,
    Callback = function(value)
        State.ESPFreezePods = value
        updateObjectESP()
    end
})

ESPObjects:AddToggle("ESPExitDoors", {
    Text = "ESP Exit Doors",
    Default = false,
    Callback = function(value)
        State.ESPExitDoors = value
        updateObjectESP()
    end
})

-- ========================================
-- PLAYER TAB
-- ========================================

local PlayerMods = Tabs.Player:AddLeftGroupbox("Modificações", "user-cog")
local PlayerSafety = Tabs.Player:AddRightGroupbox("Segurança", "shield")

PlayerMods:AddSlider("WalkSpeed", {
    Text = "Velocidade",
    Default = 16,
    Min = 16,
    Max = 200,
    Rounding = 0,
    Callback = function(value)
        State.WalkSpeed = value
        updateWalkSpeed()
    end
})

PlayerMods:AddSlider("JumpPower", {
    Text = "Força do Pulo",
    Default = 50,
    Min = 50,
    Max = 300,
    Rounding = 0,
    Callback = function(value)
        State.JumpPower = value
        updateJumpPower()
    end
})

PlayerMods:AddToggle("NoClip", {
    Text = "NoClip",
    Default = false,
    Callback = function(value)
        State.NoClip = value
        if value then
            startNoClip()
            Library:Notify("NoClip ativado!", 2)
        else
            stopNoClip()
            Library:Notify("NoClip desativado!", 2)
        end
    end
})

PlayerSafety:AddToggle("AntiBeast", {
    Text = "Anti Beast",
    Default = false,
    Callback = function(value)
        State.AntiBeast = value
        if value then
            startAntiBeast()
            Library:Notify("Anti-Beast ativado! Teleporta quando Beast se aproxima.", 3)
        else
            stopAntiBeast()
            Library:Notify("Anti-Beast desativado!", 2)
        end
    end
})

PlayerSafety:AddLabel("Teleporta automaticamente quando Beast está a menos de 30 studs", false)

-- ========================================
-- SETTINGS TAB
-- ========================================

local SettingsBox = Tabs.Settings:AddLeftGroupbox("Menu", "settings")

SettingsBox:AddButton("Unload UI", function()
    Library:Notify("Descarregando UI...", 2)
    task.wait(0.5)
    Library:Unload()
end)

SettingsBox:AddLabel("Remove completamente a interface", false)

-- ========================================
-- SAVE MANAGER
-- ========================================

SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ "MenuKeybind" })
SaveManager:SetFolder("FleeTheFacility/TestScript")
SaveManager:BuildConfigSection(Tabs.Settings)

-- ========================================
-- BACKGROUND TASKS
-- ========================================

-- Beast Chance Checker Loop
task.spawn(function()
    while task.wait(1) do
        -- Refresh dropdown
        local vals = {}
        for _, p in ipairs(Players:GetPlayers()) do
            table.insert(vals, p.Name)
        end
        if #vals > 0 then 
            BeastChanceDropdown:SetValues(vals)
        end

        -- Update selected player's beast chance
        if State.SelectedPlayerForChance then
            local player = Players:FindFirstChild(State.SelectedPlayerForChance)
            local info = "Jogador não encontrado"
            if player then
                local mod = player:FindFirstChild("SavedPlayerStatsModule")
                if mod then
                    local val = mod:FindFirstChild("BeastChance")
                    info = val and (State.SelectedPlayerForChance .. ": " .. tostring(val.Value) .. "%") or "BeastChance não encontrado"
                else
                    info = "SavedPlayerStatsModule não encontrado"
                end
            end
            BeastChanceResult:SetText(info)
        end
    end
end)

-- Computer Dropdown Update Loop
task.spawn(function()
    while task.wait(2) do
        if Cache.ObjectsDirty then rebuildObjectCache() end
        
        local vals = {}
        for i, computer in ipairs(Cache.Computers) do
            table.insert(vals, "Computador " .. i)
        end
        
        if #vals > 0 then
            ComputerDropdown:SetValues(vals)
        end
    end
end)

-- ESP Update Loop
task.spawn(function()
    while task.wait(0.5) do
        if State.ESPBeast or State.ESPPlayers then
            updatePlayerESP()
        end
    end
end)

-- Character Respawn Handler
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1)
    updateWalkSpeed()
    updateJumpPower()
end)

-- Initial Setup
Library:Notify("Script carregado com sucesso!", 3)
rebuildObjectCache()

-- Rebuild cache periodically
task.spawn(function()
    while task.wait(10) do
        Cache.ObjectsDirty = true
    end
end)
